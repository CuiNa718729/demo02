<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<style>

</style>
<body>
<ul id="test">
    <li>这是第一条</li>
    <li>这是第二条</li>
    <li>这是第三条</li>
</ul>

<form action="">
    <input type="radio" name="radioGroup"/>
    <input type="radio" name="radioGroup"/>
    <input type="radio" name="radioGroup"/>
    <input type="radio" name="radioGroup"/>
    <input type="submit"/>
</form>
<script src="js/jquery-1.11.3.js"></script>
<script>
//设计一个函数将数字类型转千分位表示（4705618.32）
			function million(num){
				var s = parseFloat(num);
				s +="";
				//如果没有小数点，在后面补0
				//indexOf(关键词，fromi)关键词用"",fromi从哪个位置开始查找，没找到返回-1
				if(s.indexOf(".") == -1){
					s +=".0";
				}
				
				//.test()验证str是否符合正则的要求
				/*if(/\.\d$/.test(s)){
					s +="0";
				}*/				
				//正则判断
				while(/\d{4}(.|,)/.test(s)){
					//符合条件进行替换
					s = s.replace(/(\d)(\d{3}(\.|,))/,"$1,$2");
					//每隔三位添加一个，
				}
				alert(s);
			}
			million(2144668689.32);


<!--  函数声明提前 -->
	<!-- 函数声明语句会被提前到脚本或函数的顶部 -->
		<script>
			function bar(){
				//相当于：function foo(){};
				return foo;//将foo函数返回
				//后面语句不执行
				foo = 10;
				var foo = 11;
				function foo(){};
				console.log(foo);
			}
			//alert(typeof bar());
			console.log(bar());//函数
			//console.log(foo);//报错
		

			console.log(a);//function a(){}; 函数声明提前
			var a = 3;//变量a把函数a覆盖
			function a(){};//函数声明提到最前面
			console.log(a);//3

			function bar(){
				foo = 10;
				return;
				function foo(){};
			}
			bar();
			console.log(foo);//报错，函数声明提前
		
			alert(a in window);//true
			var a = 10;
		
		
			/*
			  函数的声明提前到脚本的顶部，
			  也就是说函数可以提前调用，同名函数后定义的会覆盖先定义的
			*/
			function f(){
				alert(1);
			}
			f();//10
			function f(){
				alert(10);
			}
			f();//10
	
		
			alert(a);//函数
			var a=1;//变量a覆盖函数a
			function a(){};//函数声明提前
			alert(a);//1
	

			var a = 1;
			var b = function a(){
				alert(a);
			}
			//alert(a);//1
			b();//function a(){alert(a);}

      var x=3;
			var foo={
				x:2,
				baz:{
					x:1,
					bar:function(){
						return this.x;
					}
				}
			}
			var go = foo.baz.bar;
			//this的最终指向的是调用它的对象
			console.log(go());//3 直接把foo.baz.bar当作一个整体去调用，
			console.log(foo.baz.bar());//1对象的方法中要使用对象自己的属性必须写成this.属性名


     var foo = {
	bar:function(){
		return this.baz;
	},
	baz:1
 }
 var bar='asdf';
 window.bar=[1,2,3];
 var c=typeof(function(){
	this.a = foo;
	return this;
 })().a.bar;
 var d=typeof(f=foo.bar)();
 alert(c),alert(d);
 console.log((function(){
	console.log(1);
	setTimeout(function(){
		console.log(2);
	},1000);
	setTimeout(function(){
		console.log(3);
	},0);
	setTimeout(function(){
		console.log(5);
	},0);
	console.log(4);
 })());
 console.log(NaN*3);
 var a=100;
 function test(){
	alert(a);
	var a =10;
	alert(a);
 }
	test();


//var lis=document.querySelectorAll("li");
//    document.querySelector("#test").onclick=function(e){
//        for(var i=0;i<lis.length;i++){
//            var li=lis[i];
//            if(li= e.target){
//                alert(i);
//            }
//        }
//    }
//    var lis=document.querySelectorAll("li");
//    for(var i=0;i<lis.length;i++){
//        var li=lis[i];
//        li.onclick=(function(index){
//            return function(e){
//                alert(index);
//            };
//        })(i);
//
//    for(var i=0;i<5;++i){
//        setTimeout(function(){
//            console.log(i+"")
//        },100*i)
//    }
////5个5
//    setTimeout(function(){
//        for(var i=0;i<5;++i){
//            console.log(i+"")
//        }
//    },100*i)
//0 1 2 3 4



//    var t=10;
//    function test(test){
//         t=t+test;
//        console.log(t);
//    }test(12);
//    console.log(t);


    function serilizeUrl(url) {
        var url="http://item.taobao.com/item.html?a=1&b=2&c=3";
       var urlObject={};
        if(/\?/.test(url)){
            var urlString=url.substring(url.indexOf("?")+1);
            var urlArray=urlString.split("&");
            for(var i= 0,len=urlArray.length;i<len;i++){
                var urlItem=urlArray[i];
                var item=urlItem.split("=");
                urlObject[item[0]]=item[1];
            }
            return urlObject;
            alert(0);
        }
        return null;
    }
serilizeUrl();


//计算两个日期之间差多少天多少小时多少分
//    var date1=new Date();
//    var date2=new Date("2017/2/17");
//    var newDate=date1-date2;
//    console.log(newDate);
//    var day=parseInt(newDate/(3600*24*1000));
//    console.log(day);
//    var hours=parseInt(newDate%(3600*24*1000)/(3600*1000));
//    console.log(hours);
//    var minutes=parseInt(newDate%(3600*1000)/(60*1000));
//    console.log(minutes);
//
//
//
//    function setN(obj){
//        obj.name="屌丝";
//        obj=new Object();
//        obj.name="腐女";
//    };
//    var per=new Object();
//    setN(per);
//    alert(per.name);
//
//
//
//
//    window.color="red";
//    var o={color:"blue"};
//    function sayColor(){
//        alert(this.color);
//    }
//
//sayColor();
//    sayColor.call(this);
//    sayColor.call(window);
//    sayColor.call(o);
//
//
//
//    function foo(){
//        foo.a=function(){alert(1)};
//        this.a=function(){alert(2)};
//        a=function(){alert(3)};
//        var a=function(){alert(4)};
//    };
//    foo.prototype.a=function(){alert(5)};
//    foo.a=function(){alert(6)};
//    foo.a();//6
//    var obj=new foo();
//    obj.a();//2
//    foo.a();//1
//
//
//
//    var a=5;
//    function test(){
//        var a;
//        a=0;
//        alert(a);
//        alert(this.a);
//        alert(a);
//    }
//    test();//
//    // 0 5 0
//    var obj=new test(); //0 undefined 0



//
//    var a=6;
//    setTimeout(function(){
//        alert(a);
//        var a=666;
//    },1000)
//    a=666;
//    alert(a);

//
//    function f1(){
//        var tmp=1;
//        this.x=3;
//        console.log(tmp);
//        console.log(this.x);
//    }
//    var obj=new f1();
//    console.log(obj.x);//1 3
//    console.log(f1());//1 3 undefined
//

//
//    var str="12345678";
//    str=str.split("").reverse().join();
//    console.log(str);

    
    function radio(){
         var inputs=document.querySelectorAll("input");
        inputs.onclick=function(e){
            for(var i= 1,len=inputs.length;i<len;i++){
                var inputIndex=inputs[i];
                if(inputIndex==e.target){
                    alert(i);
                    alert(3);
                }
            }

        }
        console.log(inputs);
        }
    radio();




//    var a=10,b=20,c=30;
//    ++a;
//    a++;
//    e=++a+(++b)+(c++)+a++;
//    alert(e);
//
//var arr=new Array(1,3,5);
//    arr[4]='z';
//console.log(arr);
//    arr2=arr.reverse();
//console.log(arr2);
//    arr3=arr.concat(arr2);
//    alert(arr3);


//    var str=[1,2,3,4,5];
//    str=str.reverse();
//    console.log(str);
//
//    alert(1&&2);//短路逻辑 短路与  两个条件都为真 结果才为真否则为假；短路或 一个条件为真就为真 两个都为假 结果为假
//    alert(0||1);//0 undefined null ""结果都是false
//console.log(Boolean(""));//false

//

//    var a=1;
//    function test(){
//        a=3;
//        return;
//        function a(){};//声明提前
//    }
//console.log(a);//1
//test();
//    console.log(a);//1


//var a=1;
//function test(){
//    a=3;
//    return;
//   // function a(){}; a=3;为全局变量  覆盖了a=1；
//}
//console.log(a);//1
//test();
//console.log(a);//3


//
//var foo="11"+2-"1";
//    console.log(foo);
//    console.log(typeof foo);



//  function foo(a
//  ){
//      arguments[0]=2;
//      arguments[1]=3;
//      alert(a);
//      //alert(b);
//      console.log(arguments.length);
//  }
//    foo(1,2);



//
//function foo(){
//    alert(arguments.length);
//    alert(arguments[0]+arguments[1]);
//    console.log(arguments[0]);
//    console.log(arguments[1]);
//}
//    foo("string",45);// 2 string45 string 45
//    foo();//0 NaN undefined undefined
//    foo(12);//1 NaN 12 undefined



//function bar(){
//    return foo;
//    foo=10;
//    function foo(){};
//}
//    alert(typeof bar());//function
//    console.log(foo);// 报错 foo is not defined
//
//var foo=1;
//    function bar(){
//        foo=10;
//        return;
//        function foo(){};
//    }
//    bar();
//    alert(foo);//1



//
//    var arrA=[1,2,3,4,5];
//    var arrB=[];
//    for(var i=0;i<arrA.length;i++){
//        arrB.push(function(){
//            alert(i);
//        })
//    }
//    arrB[2]();//5


////
//var arr=[3,6,2,1,4,5];
////    arr=arr.reverse();
////    console.log(arr);
//function bubbleSort(){
//for(var r=1;r<arr.length;r++){
//   for(var i=0;i<arr.length-r;i++){
//       arr[i]>arr[i+1]&&
//       (   arr[i]^=arr[i+1],
//           arr[i+1]^=arr[i],
//           arr[i]^=arr[i+1]);
//        }
//    }
//}
//bubbleSort(arr);
//console.log(arr);
//
//var a=[1,2,3,4,5,6,7,8,9];
//    var b=["a","b","c"];
//    //用什么方法使其变成1，2,3，a，4,5,6，b，7,8,9，c
//   // 方法一
//var c= a.join("");
//    console.log(c);
//    var c= c.replace(/(\d{3})(\d{3})(\d{3})/,"$1"+b[0]+"$2"+b[1]+"$3"+b[2]);
//    console.log(c);
//
//////    方法2
////a.splice(3,0,b[0]);
////a.splice(7,0,b[1]);
////a.splice(11,0,b[2]);
////    console.log(a);
////    方法三：
//for(var i= 0,r=3;i< b.length;i++){
//    a.splice(r*i+r+i,0,b[i]);
//}
//    console.log(a);


//    var name="jim";
//    var object={
//        name:"tom",
//        getNameFunc:function(){
//            return function(){
//                return this.name;
//            };
//        }
//    };
//    alert(object.getNameFunc()());//jim
////    var fun=object.getNameFunc(); 这个返回的是一个函数,
////        也就是fun=function(){return this.name}此时fun中this指向window
//var name="jim";
//var object={
//    name:"tom",
//    getNameFunc:function(){
//        var that=this;//这里的that现在相当于object这个对象了
//        return function() {
//            return that.name;//object.name
//        }
//    }
//}
//alert(object.getNameFunc()());//tom



//function getQueryString(url){
//    //var url=api.ab.com/test?username=jim&age=25&sex=1;
//    var obj={};
//    var search=url.substring(url.indexOf("?")+1);
//    var urlArray=search.split("&");
//    for(var i=0;i<urlArray.length;i++){
//        var items=urlArray[i];
//        var item=items.split("=");
//        obj[item[0]]=item[1];
//    }
//    return obj;
//}
//getQueryString();
//    console.log(username);
//console.log(window.name());

//var obj={
//    name:"object",
//    show:function(){
//        alert(this.name);
//    }
//};
////(obj.show=obj.show)();name是js保留关键字  最好不要用
////相当于
//var obj=obj.show;
//obj();//obj前没有。调用
// this指向window 所以为空  如果变量不是name  为undefined


//    function f1(){
//        var tmp=1;
//        this.x=3;
//       // return;
//        console.log(tmp);
//        console.log(this.x);
//    }
//    var obj=new f1();//1 3
//    console.log(obj.x);//3
//    console.log(f1());// 1 3 undefined 把f1()当作一个变量输出 没有return的时候输出undefined


//代码中，constructor方法和toString方法之中，都出现了 super关键字 ，它在这里表示父类的构造函数，用来新建父类的this对象。
//super这个关键字，既可以当作函数使用，也可以当作对象使用。 第一种情况，super作为函数调用时，代表父类的构造函数，只能用在子类的构造函数中。ES6 要求，子类的构造函数必须执行一次super函数。第二种情况，super作为对象时，指代父类的原型对象。
//ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。（ES5通过原型模式的继承：创建子类，然后将父类的实例赋值给子类原型，也就是重写子类原型，代之以一个新类型的实例。）ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。
//如果子类没有定义constructor方法，这个方法会被默认添加。在子类的构造函数中， 只有调用super之后，才可以使用this关键字，否则会报错 。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。
    (window.xxx || (window.xxx="bar"));
    console.log(window.xxx);
   var foo="hello";
(function(){
    var bar="world";
     console.log(foo+bar);//hello world
})();
    //console.log(foo+bar); //bar is not defined

var foo=1;
(function(){
   console.log(foo);//undefined
    var foo=2;
   console.log(foo);//2
})();
    function Foo(){
        getName=function(){
            alert(1);
        };
        return this;
    }
    Foo.getName=function(){
        alert(2);
    };
    Foo.prototype.getName=function(){
        alert('baidu'&&'google');
    };
    var getName=function(){
        alert(4);
    };
    function getName(){
        alert(5+1);
    }
    Foo.getName();//2
    getName();//4
    Foo().getName();//1
    getName();//1
    new Foo().getName();//google
    new new Foo().getName();//google





    class Emp{
        constructor(ename){
            this.ename=ename;
        }
        work(){
            return `${this.ename} is working.`;
        };
    }
    class Programmer extends Emp{
        constructor(ename,salary,skills){
            super(ename,salary);//调用父类的constructior(x,y)
            this.skills=skills;
        }
        work(){
            return super.work()+'He\'s skills is '+this.skills;
        }
    }
    var emp1=new Programmer("Lily",1000,"java");
    console.log(emp1.ename);
    console.log(emp1.work());

    var str="aaaaaadddsssfffffffffff";
    var json={};//创建一个空对象 用于保存字符
    for(var i=0;i<str.length;i++){//保存字符串
        if(!json[str.charAt(i)]){//如果json对象中没有当前字符串的属性
            json[str.charAt(i)]=1;//将当前字符串的属性赋值为1
        }else{//json对象中有当前字符的属性
            json[str.charAt(i)]++;//将当前字符串的属性值自增
        }
    };
    var iMax=0;//保存最大值
    var iIndex=0;//保存字符
    for(var i in json){//遍历json对象
        if(json[i]>iMax)//判断json对象中当前属性的值是否大于最大值iMax
        iMax=json[i];//大于就把当前属性值赋给iMax
        iIndex=i;//把当前属性赋值给iIndex
    }
    console.log(str.charAt(i));
    console.log(json[str.charAt(i)]);
    console.log("出现次数最多的是"+iIndex+"出现"+iMax+"次")
</script>

</body>
</html>